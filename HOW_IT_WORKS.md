# How EVE Works

A simplified walkthrough of EVE's code generation process.

## The 60-Second Version

```
You say: "Build a battery monitor with SoC calculation"

EVE does:
1. Understands what you want (Intent Analysis)
2. Finds similar code it's built before (Semantic Search)
3. Decides the best way to build it (Smart Routing)
4. Generates the code (Code Factory or AI)
5. Tests it works (AutoFix Loop)
6. Gives you working code (Output)
7. Remembers for next time (Learning)

You get: 400+ lines of tested Python in 45 seconds
```

## Step-by-Step Breakdown

### Step 1: Intent Analysis

**Input:** `"Build a battery monitor with SoC calculation"`

**EVE extracts:**
```
Type: Engine
Name: BatteryMonitor
Domain: Energy
Features: [SoC calculation]
```

No AI needed — pure pattern matching.

### Step 2: Semantic Search (RAG)

EVE searches its knowledge base for similar code:

```
Query: "battery monitor SoC"
  ↓
Semantic embedding (sentence transformer)
  ↓
GPU-accelerated cosine similarity
  ↓
Top 5 matches:
  1. battery_engine.py (91% similar)
  2. energy_monitor.py (78% similar)
  3. solar_panel_engine.py (72% similar)
  ...
```

These examples become context for code generation.

### Step 3: Smart Routing

EVE decides HOW to generate:

```
Dashboard request?     → Code Factory (2ms, templates)
Security/encryption?   → Claude API (30s, premium AI)
Standard engine?       → Local LLM (2-4min, free)
```

This routing is the key innovation — not everything needs AI.

### Step 4: Code Generation

**If Code Factory (deterministic):**
```
Template + Spec → Code
No randomness, instant, predictable
```

**If AI (Claude or Local):**
```
System prompt + RAG context + Task → AI → Code
```

The RAG context is crucial — it shows the AI real examples.

### Step 5: AutoFix Loop

Generated code goes through validation:

```
Code
  ↓
AST Parse (is it valid Python?)
  ↓ fail? → AI fix attempt
Import Check (do imports exist?)
  ↓ fail? → add missing imports
Test Execution (does it run?)
  ↓ fail? → AI fix attempt
  ↓
Up to 5 iterations
  ↓
Working Code ✅
```

### Step 6: Output

You receive:
- Complete Python file(s)
- Test file(s)
- All imports resolved
- Validation passed

### Step 7: Learning

If the build succeeded:
```
New code → Index in knowledge base
         → Available for future RAG
         → EVE gets smarter
```

## Why This Works

### 1. Templates First
80% of code follows patterns. Why use AI for `class Foo:\n    def __init__(self):` ?

### 2. Real Examples > Instructions
Showing AI 5 real examples beats 50 lines of instructions.

### 3. Validate, Don't Hope
Every output is tested. No "looks right" — it must RUN.

### 4. Learn From Success
Every working build improves future builds.

## What Makes EVE Different

| Other Tools | EVE |
|-------------|-----|
| Suggest snippets | Generate complete systems |
| Hope it works | Guarantee it compiles |
| Same approach for all | Route based on complexity |
| Start from scratch | Start from examples |
| Forget everything | Remember and improve |

## Try It

```bash
cd examples
python solar_panel_engine.py
python test_solar_panel_engine.py
```

See for yourself — this code was generated by EVE.
