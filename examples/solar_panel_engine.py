# ========================================================================
# SolarPanelEngine — Generated by EVE Genesis
# ========================================================================
# This file was automatically generated from:
#   "Build a SolarPanelEngine with MPPT optimization and weather adjustment"
#
# Generation time: 47.2 seconds
# Method: Local LLM with RAG context (5 similar examples)
# Tests: All passed on first iteration
# ========================================================================

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import math


class PanelStatus(Enum):
    """Operating status of solar panel."""
    OPTIMAL = "optimal"
    DEGRADED = "degraded"
    SHADED = "shaded"
    OFFLINE = "offline"
    MAINTENANCE = "maintenance"


@dataclass
class SolarReading:
    """Single reading from solar panel."""
    timestamp: datetime
    power_w: float
    voltage_v: float
    current_a: float
    temperature_c: float
    irradiance_wm2: float
    efficiency: float


@dataclass
class MPPTState:
    """Maximum Power Point Tracking state."""
    voltage_mpp: float
    current_mpp: float
    power_mpp: float
    tracking_efficiency: float
    last_adjustment: datetime


@dataclass
class SolarPanelResult:
    """Result from SolarPanelEngine operations."""
    success: bool
    data: Any = None
    error: str = None
    warnings: List[str] = field(default_factory=list)


class SolarPanelEngine:
    """
    Solar Panel monitoring and optimization engine.
    
    Features:
    - Real-time power monitoring
    - MPPT (Maximum Power Point Tracking) optimization
    - Weather-based efficiency adjustment
    - Degradation detection
    - Historical analysis
    
    Usage:
        engine = SolarPanelEngine(panel_capacity_wp=400)
        result = engine.process_reading(voltage=38.5, current=9.2, temp=45.0)
        print(f"Power: {result.data['power_w']}W, Efficiency: {result.data['efficiency']}%")
    """
    
    VERSION = "1.0.0"
    
    # Standard Test Conditions (STC)
    STC_IRRADIANCE = 1000.0  # W/m²
    STC_TEMPERATURE = 25.0    # °C
    
    # Temperature coefficients (typical silicon panel)
    TEMP_COEFF_POWER = -0.004    # -0.4% per °C
    TEMP_COEFF_VOLTAGE = -0.003  # -0.3% per °C
    TEMP_COEFF_CURRENT = 0.0005  # +0.05% per °C
    
    def __init__(
        self,
        panel_capacity_wp: float = 400.0,
        voltage_mpp: float = 38.0,
        current_mpp: float = 10.5,
        panel_id: str = "SP001"
    ):
        """
        Initialize SolarPanelEngine.
        
        Args:
            panel_capacity_wp: Panel capacity in Wp (Watt-peak)
            voltage_mpp: Voltage at Maximum Power Point
            current_mpp: Current at Maximum Power Point
            panel_id: Unique identifier for panel
        """
        self.panel_capacity = panel_capacity_wp
        self.voltage_mpp_stc = voltage_mpp
        self.current_mpp_stc = current_mpp
        self.panel_id = panel_id
        
        # State
        self._readings: List[SolarReading] = []
        self._mppt_state: Optional[MPPTState] = None
        self._status = PanelStatus.OPTIMAL
        
        print(f"[SOLAR] v{self.VERSION} initialized — {panel_id} ({panel_capacity_wp}Wp)")
    
    # ================================================================
    # MAIN API
    # ================================================================
    
    def process_reading(
        self,
        voltage: float,
        current: float,
        temperature: float,
        irradiance: float = None
    ) -> SolarPanelResult:
        """
        Process a new reading from the solar panel.
        
        Args:
            voltage: Measured voltage (V)
            current: Measured current (A)
            temperature: Panel temperature (°C)
            irradiance: Solar irradiance (W/m²), estimated if not provided
            
        Returns:
            SolarPanelResult with power, efficiency, and status
        """
        try:
            # Calculate power
            power = voltage * current
            
            # Estimate irradiance if not provided
            if irradiance is None:
                irradiance = self._estimate_irradiance(power, temperature)
            
            # Calculate efficiency
            efficiency = self._calculate_efficiency(power, irradiance, temperature)
            
            # Create reading
            reading = SolarReading(
                timestamp=datetime.now(),
                power_w=power,
                voltage_v=voltage,
                current_a=current,
                temperature_c=temperature,
                irradiance_wm2=irradiance,
                efficiency=efficiency
            )
            
            # Store reading
            self._readings.append(reading)
            self._limit_history(1000)
            
            # Update MPPT
            self._update_mppt(reading)
            
            # Check status
            warnings = self._check_status(reading)
            
            return SolarPanelResult(
                success=True,
                data={
                    "power_w": round(power, 2),
                    "voltage_v": round(voltage, 2),
                    "current_a": round(current, 2),
                    "efficiency": round(efficiency, 1),
                    "status": self._status.value,
                    "mppt": self._get_mppt_dict()
                },
                warnings=warnings
            )
            
        except Exception as e:
            return SolarPanelResult(success=False, error=str(e))
    
    def get_daily_production(self, date: datetime = None) -> SolarPanelResult:
        """
        Get total energy production for a day.
        
        Args:
            date: Date to query (default: today)
            
        Returns:
            SolarPanelResult with kWh produced
        """
        date = date or datetime.now()
        
        try:
            # Filter readings for the date
            day_readings = [
                r for r in self._readings
                if r.timestamp.date() == date.date()
            ]
            
            if not day_readings:
                return SolarPanelResult(
                    success=True,
                    data={"kwh": 0.0, "readings": 0}
                )
            
            # Calculate energy (simple integration)
            total_wh = 0.0
            for i in range(1, len(day_readings)):
                dt_hours = (
                    day_readings[i].timestamp - day_readings[i-1].timestamp
                ).total_seconds() / 3600
                avg_power = (day_readings[i].power_w + day_readings[i-1].power_w) / 2
                total_wh += avg_power * dt_hours
            
            return SolarPanelResult(
                success=True,
                data={
                    "kwh": round(total_wh / 1000, 3),
                    "readings": len(day_readings),
                    "peak_w": max(r.power_w for r in day_readings),
                    "avg_efficiency": sum(r.efficiency for r in day_readings) / len(day_readings)
                }
            )
            
        except Exception as e:
            return SolarPanelResult(success=False, error=str(e))
    
    def get_mppt_recommendation(self) -> SolarPanelResult:
        """
        Get MPPT optimization recommendation.
        
        Returns:
            SolarPanelResult with recommended voltage/current setpoints
        """
        if not self._mppt_state:
            return SolarPanelResult(
                success=False,
                error="Insufficient data for MPPT recommendation"
            )
        
        return SolarPanelResult(
            success=True,
            data={
                "recommended_voltage": round(self._mppt_state.voltage_mpp, 2),
                "recommended_current": round(self._mppt_state.current_mpp, 2),
                "expected_power": round(self._mppt_state.power_mpp, 2),
                "tracking_efficiency": round(self._mppt_state.tracking_efficiency, 1)
            }
        )
    
    # ================================================================
    # MPPT LOGIC
    # ================================================================
    
    def _update_mppt(self, reading: SolarReading) -> None:
        """Update MPPT state based on new reading."""
        # Temperature-adjusted MPP voltage
        temp_delta = reading.temperature_c - self.STC_TEMPERATURE
        voltage_adj = self.voltage_mpp_stc * (1 + self.TEMP_COEFF_VOLTAGE * temp_delta)
        
        # Irradiance-adjusted MPP current
        irr_factor = reading.irradiance_wm2 / self.STC_IRRADIANCE
        current_adj = self.current_mpp_stc * irr_factor * (
            1 + self.TEMP_COEFF_CURRENT * temp_delta
        )
        
        # Expected power at MPP
        power_mpp = voltage_adj * current_adj
        
        # Tracking efficiency
        tracking_eff = (reading.power_w / power_mpp * 100) if power_mpp > 0 else 0
        
        self._mppt_state = MPPTState(
            voltage_mpp=voltage_adj,
            current_mpp=current_adj,
            power_mpp=power_mpp,
            tracking_efficiency=min(tracking_eff, 100),
            last_adjustment=datetime.now()
        )
    
    def _get_mppt_dict(self) -> Optional[Dict]:
        """Convert MPPT state to dict."""
        if not self._mppt_state:
            return None
        return {
            "voltage_mpp": round(self._mppt_state.voltage_mpp, 2),
            "current_mpp": round(self._mppt_state.current_mpp, 2),
            "power_mpp": round(self._mppt_state.power_mpp, 2),
            "tracking_efficiency": round(self._mppt_state.tracking_efficiency, 1)
        }
    
    # ================================================================
    # CALCULATIONS
    # ================================================================
    
    def _calculate_efficiency(
        self,
        power: float,
        irradiance: float,
        temperature: float
    ) -> float:
        """
        Calculate panel efficiency considering temperature.
        
        Args:
            power: Measured power (W)
            irradiance: Solar irradiance (W/m²)
            temperature: Panel temperature (°C)
            
        Returns:
            Efficiency as percentage
        """
        if irradiance <= 0:
            return 0.0
        
        # Temperature derating
        temp_delta = temperature - self.STC_TEMPERATURE
        temp_factor = 1 + (self.TEMP_COEFF_POWER * temp_delta)
        
        # Adjusted capacity
        capacity_adj = self.panel_capacity * temp_factor
        
        # Expected power at current irradiance
        expected_power = capacity_adj * (irradiance / self.STC_IRRADIANCE)
        
        if expected_power <= 0:
            return 0.0
        
        return min((power / expected_power) * 100, 100)
    
    def _estimate_irradiance(self, power: float, temperature: float) -> float:
        """Estimate irradiance from power and temperature."""
        if power <= 0:
            return 0.0
        
        # Reverse calculation
        temp_delta = temperature - self.STC_TEMPERATURE
        temp_factor = 1 + (self.TEMP_COEFF_POWER * temp_delta)
        capacity_adj = self.panel_capacity * temp_factor
        
        if capacity_adj <= 0:
            return 0.0
        
        return (power / capacity_adj) * self.STC_IRRADIANCE
    
    # ================================================================
    # STATUS MONITORING
    # ================================================================
    
    def _check_status(self, reading: SolarReading) -> List[str]:
        """Check panel status and return warnings."""
        warnings = []
        
        # Check for shading (sudden efficiency drop)
        if reading.efficiency < 50 and reading.irradiance_wm2 > 200:
            self._status = PanelStatus.SHADED
            warnings.append("Possible shading detected")
        
        # Check for degradation (consistently low efficiency)
        elif reading.efficiency < 70:
            self._status = PanelStatus.DEGRADED
            warnings.append("Panel efficiency below expected")
        
        # Check temperature
        elif reading.temperature_c > 75:
            warnings.append(f"High temperature: {reading.temperature_c}°C")
            self._status = PanelStatus.DEGRADED
        
        else:
            self._status = PanelStatus.OPTIMAL
        
        return warnings
    
    def _limit_history(self, max_readings: int) -> None:
        """Limit stored readings to prevent memory issues."""
        if len(self._readings) > max_readings:
            self._readings = self._readings[-max_readings:]


# ========================================================================
# SINGLETON
# ========================================================================

_instance = None

def get_solar_engine() -> SolarPanelEngine:
    """Get or create singleton instance."""
    global _instance
    if _instance is None:
        _instance = SolarPanelEngine()
    return _instance


# ========================================================================
# CLI / TEST
# ========================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("SOLARPANELENGINE — EVE Genesis Demo")
    print("=" * 60)
    
    # Create engine
    engine = SolarPanelEngine(
        panel_capacity_wp=400,
        voltage_mpp=38.0,
        current_mpp=10.5,
        panel_id="DEMO-001"
    )
    
    # Simulate readings
    test_cases = [
        (37.5, 9.8, 35.0, 850),   # Good conditions
        (36.0, 8.5, 45.0, 700),   # Hot day
        (38.0, 5.0, 30.0, 400),   # Cloudy
        (35.0, 2.0, 25.0, 150),   # Heavy clouds
    ]
    
    print("\n--- Processing Readings ---")
    for voltage, current, temp, irr in test_cases:
        result = engine.process_reading(voltage, current, temp, irr)
        if result.success:
            d = result.data
            print(f"  {d['power_w']:6.1f}W | {d['efficiency']:5.1f}% | {d['status']}")
            if result.warnings:
                print(f"    ⚠️ {result.warnings}")
    
    # MPPT recommendation
    print("\n--- MPPT Recommendation ---")
    mppt = engine.get_mppt_recommendation()
    if mppt.success:
        print(f"  Voltage: {mppt.data['recommended_voltage']}V")
        print(f"  Current: {mppt.data['recommended_current']}A")
        print(f"  Expected: {mppt.data['expected_power']}W")
    
    print("\n✅ Demo complete!")
