"""
EVChargingEngine — Smart EV Charging Management

Generated by EVE Self-Coding Platform
Demonstrates: Load management, scheduling, V2G support

Features:
- Smart charging schedules
- Load balancing across chargers
- Spot price optimization
- Vehicle-to-Grid (V2G) support
- Dynamic load management
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum
from datetime import datetime, timedelta
import math


class ChargerState(Enum):
    """Charger operating states."""
    AVAILABLE = "available"
    CHARGING = "charging"
    DISCHARGING = "discharging"  # V2G
    WAITING = "waiting"          # Waiting for schedule
    FAULT = "fault"
    OFFLINE = "offline"


class ChargerType(Enum):
    """Charger types."""
    AC_TYPE2 = "ac_type2"        # Type 2, up to 22kW
    DC_CCS = "dc_ccs"            # CCS, up to 350kW
    DC_CHADEMO = "dc_chademo"    # CHAdeMO, up to 100kW
    AC_SCHUKO = "ac_schuko"      # Standard outlet, 3.7kW


@dataclass
class Charger:
    """EV charger configuration."""
    id: str
    charger_type: ChargerType
    max_power_kw: float
    current_power_kw: float = 0.0
    state: ChargerState = ChargerState.AVAILABLE
    v2g_capable: bool = False
    location: str = ""
    
    @property
    def utilization(self) -> float:
        if self.max_power_kw <= 0:
            return 0.0
        return self.current_power_kw / self.max_power_kw


@dataclass
class ChargingSession:
    """Active charging session."""
    session_id: str
    charger_id: str
    vehicle_id: str
    start_time: datetime
    target_soc: float = 80.0
    target_time: Optional[datetime] = None
    current_soc: float = 0.0
    battery_capacity_kwh: float = 60.0
    energy_delivered_kwh: float = 0.0
    priority: int = 1  # 1 = highest


@dataclass
class ChargingSchedule:
    """Scheduled charging slot."""
    session_id: str
    start_time: datetime
    end_time: datetime
    power_kw: float
    cost_estimate: float = 0.0


@dataclass
class LoadBalanceResult:
    """Result of load balancing calculation."""
    success: bool
    allocations: Dict[str, float]  # charger_id → power
    total_power_kw: float
    headroom_kw: float
    messages: List[str] = field(default_factory=list)


class EVChargingEngine:
    """
    Smart EV Charging Management System.
    
    Features:
    - Multi-charger load balancing
    - Time-of-use optimization
    - V2G (Vehicle-to-Grid) support
    - Priority-based scheduling
    - Dynamic load management
    
    Usage:
        engine = EVChargingEngine(site_capacity_kw=100)
        
        # Add chargers
        engine.add_charger(Charger("cp1", ChargerType.DC_CCS, 50))
        engine.add_charger(Charger("cp2", ChargerType.AC_TYPE2, 22))
        
        # Start session
        session = engine.start_session("cp1", "VH123", target_soc=80)
        
        # Balance load
        result = engine.balance_load(available_power=80)
    """
    
    VERSION = "1.0.0"
    
    def __init__(self, site_capacity_kw: float = 100.0):
        """
        Initialize EVChargingEngine.
        
        Args:
            site_capacity_kw: Maximum site power capacity
        """
        self.site_capacity_kw = site_capacity_kw
        self.chargers: Dict[str, Charger] = {}
        self.sessions: Dict[str, ChargingSession] = {}
        self.schedules: List[ChargingSchedule] = []
        self.spot_prices: List[Tuple[datetime, float]] = []
        
        # Site load (other than EV)
        self.base_load_kw = 0.0
        
    # ================================================================
    # CHARGER MANAGEMENT
    # ================================================================
    
    def add_charger(self, charger: Charger) -> None:
        """Add a charger to the system."""
        self.chargers[charger.id] = charger
        
    def remove_charger(self, charger_id: str) -> bool:
        """Remove a charger."""
        if charger_id in self.chargers:
            del self.chargers[charger_id]
            return True
        return False
    
    def get_charger_status(self, charger_id: str) -> Optional[Charger]:
        """Get charger status."""
        return self.chargers.get(charger_id)
    
    def get_available_chargers(self) -> List[Charger]:
        """Get list of available chargers."""
        return [c for c in self.chargers.values() if c.state == ChargerState.AVAILABLE]
    
    # ================================================================
    # SESSION MANAGEMENT
    # ================================================================
    
    def start_session(
        self,
        charger_id: str,
        vehicle_id: str,
        current_soc: float = 20.0,
        target_soc: float = 80.0,
        target_time: datetime = None,
        battery_capacity_kwh: float = 60.0,
        priority: int = 1
    ) -> Optional[ChargingSession]:
        """
        Start a new charging session.
        
        Args:
            charger_id: Charger to use
            vehicle_id: Vehicle identifier
            current_soc: Current battery SoC (%)
            target_soc: Target SoC (%)
            target_time: Must be ready by this time
            battery_capacity_kwh: Vehicle battery capacity
            priority: Session priority (1 = highest)
            
        Returns:
            ChargingSession or None if failed
        """
        if charger_id not in self.chargers:
            return None
            
        charger = self.chargers[charger_id]
        if charger.state != ChargerState.AVAILABLE:
            return None
        
        session_id = f"sess_{charger_id}_{int(datetime.now().timestamp())}"
        
        session = ChargingSession(
            session_id=session_id,
            charger_id=charger_id,
            vehicle_id=vehicle_id,
            start_time=datetime.now(),
            target_soc=target_soc,
            target_time=target_time,
            current_soc=current_soc,
            battery_capacity_kwh=battery_capacity_kwh,
            priority=priority
        )
        
        self.sessions[session_id] = session
        charger.state = ChargerState.CHARGING
        
        return session
    
    def stop_session(self, session_id: str) -> bool:
        """Stop a charging session."""
        if session_id not in self.sessions:
            return False
            
        session = self.sessions[session_id]
        charger = self.chargers.get(session.charger_id)
        
        if charger:
            charger.state = ChargerState.AVAILABLE
            charger.current_power_kw = 0.0
            
        del self.sessions[session_id]
        return True
    
    def update_session(self, session_id: str, energy_kwh: float, current_soc: float) -> bool:
        """Update session with delivered energy."""
        if session_id not in self.sessions:
            return False
            
        session = self.sessions[session_id]
        session.energy_delivered_kwh += energy_kwh
        session.current_soc = current_soc
        
        # Check if complete
        if current_soc >= session.target_soc:
            self.stop_session(session_id)
            
        return True
    
    # ================================================================
    # LOAD BALANCING
    # ================================================================
    
    def balance_load(self, available_power: float = None) -> LoadBalanceResult:
        """
        Balance load across all active sessions.
        
        Algorithm:
        1. Calculate available power (site capacity - base load)
        2. Sort sessions by priority and urgency
        3. Allocate power respecting charger limits
        4. Apply minimum charge rates
        
        Args:
            available_power: Override available power
            
        Returns:
            LoadBalanceResult
        """
        available = available_power or (self.site_capacity_kw - self.base_load_kw)
        
        if available <= 0:
            return LoadBalanceResult(
                success=False,
                allocations={},
                total_power_kw=0,
                headroom_kw=0,
                messages=["No power available"]
            )
        
        # Get active sessions sorted by priority and urgency
        active_sessions = list(self.sessions.values())
        active_sessions.sort(key=lambda s: (s.priority, self._calculate_urgency(s)))
        
        allocations: Dict[str, float] = {}
        remaining_power = available
        messages = []
        
        for session in active_sessions:
            charger = self.chargers.get(session.charger_id)
            if not charger:
                continue
            
            # Calculate needed power
            needed_power = self._calculate_needed_power(session)
            
            # Allocate respecting limits
            max_charger_power = charger.max_power_kw
            allocated = min(needed_power, max_charger_power, remaining_power)
            
            # Ensure minimum useful charge rate (1kW)
            if allocated < 1.0 and remaining_power >= 1.0:
                allocated = min(1.0, remaining_power)
            elif allocated < 1.0:
                allocated = 0.0
                messages.append(f"Paused {session.session_id}: insufficient power")
            
            allocations[session.charger_id] = allocated
            charger.current_power_kw = allocated
            remaining_power -= allocated
            
        total_allocated = sum(allocations.values())
        
        return LoadBalanceResult(
            success=True,
            allocations=allocations,
            total_power_kw=total_allocated,
            headroom_kw=remaining_power,
            messages=messages
        )
    
    def _calculate_urgency(self, session: ChargingSession) -> float:
        """Calculate session urgency (0-1, higher = more urgent)."""
        if not session.target_time:
            return 0.5  # Default medium urgency
            
        now = datetime.now()
        time_remaining = (session.target_time - now).total_seconds() / 3600  # hours
        
        # Calculate energy needed
        energy_needed = (
            session.battery_capacity_kwh * 
            (session.target_soc - session.current_soc) / 100
        )
        
        # Get charger power
        charger = self.chargers.get(session.charger_id)
        max_power = charger.max_power_kw if charger else 10.0
        
        # Calculate minimum time needed
        min_time_needed = energy_needed / max_power
        
        if time_remaining <= 0:
            return 1.0  # Overdue
        
        return min(min_time_needed / time_remaining, 1.0)
    
    def _calculate_needed_power(self, session: ChargingSession) -> float:
        """Calculate power needed to meet target."""
        energy_needed = (
            session.battery_capacity_kwh * 
            (session.target_soc - session.current_soc) / 100
        )
        
        if not session.target_time:
            # No deadline: charge at reasonable rate
            return min(energy_needed * 2, 22.0)  # Max 22kW for no-deadline
        
        time_remaining = (session.target_time - datetime.now()).total_seconds() / 3600
        
        if time_remaining <= 0:
            return float('inf')  # Need max power
            
        return energy_needed / time_remaining
    
    # ================================================================
    # SMART SCHEDULING
    # ================================================================
    
    def set_spot_prices(self, prices: List[Tuple[datetime, float]]) -> None:
        """Set spot price forecast."""
        self.spot_prices = sorted(prices, key=lambda x: x[0])
    
    def create_smart_schedule(self, session_id: str) -> List[ChargingSchedule]:
        """
        Create optimized charging schedule based on spot prices.
        
        Prioritizes charging during low-price periods while
        ensuring target SoC is reached by target time.
        
        Args:
            session_id: Session to schedule
            
        Returns:
            List of charging slots
        """
        if session_id not in self.sessions:
            return []
            
        session = self.sessions[session_id]
        charger = self.chargers.get(session.charger_id)
        
        if not charger or not self.spot_prices:
            return []
        
        # Calculate energy needed
        energy_needed = (
            session.battery_capacity_kwh * 
            (session.target_soc - session.current_soc) / 100
        )
        
        # Filter prices within our window
        now = datetime.now()
        end_time = session.target_time or (now + timedelta(hours=8))
        
        available_slots = [
            (t, p) for t, p in self.spot_prices 
            if now <= t < end_time
        ]
        
        if not available_slots:
            return []
        
        # Sort by price (cheapest first)
        available_slots.sort(key=lambda x: x[1])
        
        # Allocate energy to cheapest slots
        schedules = []
        remaining_energy = energy_needed
        
        for slot_time, price in available_slots:
            if remaining_energy <= 0:
                break
                
            # Assume 1-hour slots
            max_energy = charger.max_power_kw * 1.0  # 1 hour
            slot_energy = min(remaining_energy, max_energy)
            
            schedules.append(ChargingSchedule(
                session_id=session_id,
                start_time=slot_time,
                end_time=slot_time + timedelta(hours=1),
                power_kw=slot_energy,
                cost_estimate=slot_energy * price
            ))
            
            remaining_energy -= slot_energy
        
        # Sort by time for execution
        schedules.sort(key=lambda s: s.start_time)
        
        return schedules
    
    def estimate_cost(self, session_id: str) -> Dict:
        """Estimate charging cost for a session."""
        schedule = self.create_smart_schedule(session_id)
        
        if not schedule:
            return {"error": "Cannot create schedule"}
        
        total_cost = sum(s.cost_estimate for s in schedule)
        total_energy = sum(s.power_kw for s in schedule)
        avg_price = total_cost / total_energy if total_energy > 0 else 0
        
        # Compare to immediate charging
        immediate_cost = total_energy * (self.spot_prices[0][1] if self.spot_prices else 0.15)
        savings = immediate_cost - total_cost
        
        return {
            "total_energy_kwh": total_energy,
            "smart_cost": total_cost,
            "immediate_cost": immediate_cost,
            "savings": savings,
            "avg_price": avg_price,
            "schedule_slots": len(schedule)
        }
    
    # ================================================================
    # V2G (Vehicle-to-Grid)
    # ================================================================
    
    def enable_v2g(self, session_id: str, min_soc: float = 30.0) -> bool:
        """
        Enable V2G for a session.
        
        Args:
            session_id: Session to enable V2G for
            min_soc: Minimum SoC to maintain
            
        Returns:
            Success status
        """
        if session_id not in self.sessions:
            return False
            
        session = self.sessions[session_id]
        charger = self.chargers.get(session.charger_id)
        
        if not charger or not charger.v2g_capable:
            return False
        
        # Store V2G settings
        session._v2g_enabled = True
        session._v2g_min_soc = min_soc
        
        return True
    
    def request_v2g_discharge(self, power_kw: float) -> Dict[str, float]:
        """
        Request V2G discharge from available vehicles.
        
        Args:
            power_kw: Requested discharge power
            
        Returns:
            Dict of session_id → allocated discharge power
        """
        allocations = {}
        remaining_request = power_kw
        
        for session_id, session in self.sessions.items():
            if remaining_request <= 0:
                break
                
            if not getattr(session, '_v2g_enabled', False):
                continue
                
            charger = self.chargers.get(session.charger_id)
            if not charger or not charger.v2g_capable:
                continue
            
            min_soc = getattr(session, '_v2g_min_soc', 30.0)
            available_energy = (
                session.battery_capacity_kwh * 
                (session.current_soc - min_soc) / 100
            )
            
            if available_energy <= 0:
                continue
            
            # Allocate up to charger limit
            allocated = min(charger.max_power_kw, remaining_request)
            allocations[session_id] = allocated
            remaining_request -= allocated
            
            charger.state = ChargerState.DISCHARGING
            charger.current_power_kw = -allocated
            
        return allocations
    
    # ================================================================
    # STATUS & REPORTING
    # ================================================================
    
    def get_site_status(self) -> Dict:
        """Get overall site status."""
        total_power = sum(c.current_power_kw for c in self.chargers.values())
        total_capacity = sum(c.max_power_kw for c in self.chargers.values())
        
        return {
            "site_capacity_kw": self.site_capacity_kw,
            "base_load_kw": self.base_load_kw,
            "ev_power_kw": total_power,
            "available_power_kw": self.site_capacity_kw - self.base_load_kw - total_power,
            "chargers_total": len(self.chargers),
            "chargers_available": len(self.get_available_chargers()),
            "active_sessions": len(self.sessions),
            "total_charger_capacity_kw": total_capacity
        }
    
    def get_session_status(self, session_id: str) -> Optional[Dict]:
        """Get session status."""
        if session_id not in self.sessions:
            return None
            
        session = self.sessions[session_id]
        charger = self.chargers.get(session.charger_id)
        
        return {
            "session_id": session_id,
            "vehicle_id": session.vehicle_id,
            "charger_id": session.charger_id,
            "current_soc": session.current_soc,
            "target_soc": session.target_soc,
            "energy_delivered_kwh": session.energy_delivered_kwh,
            "current_power_kw": charger.current_power_kw if charger else 0,
            "time_elapsed": str(datetime.now() - session.start_time)
        }


# ========================================================================
# SINGLETON
# ========================================================================

_instance = None

def get_ev_charging_engine() -> EVChargingEngine:
    """Get or create singleton instance."""
    global _instance
    if _instance is None:
        _instance = EVChargingEngine()
    return _instance


# ========================================================================
# CLI TEST
# ========================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("⚡ EV CHARGING ENGINE — TEST")
    print("=" * 60)
    
    engine = EVChargingEngine(site_capacity_kw=150)
    
    # Add chargers
    engine.add_charger(Charger("dc1", ChargerType.DC_CCS, 50, v2g_capable=True))
    engine.add_charger(Charger("dc2", ChargerType.DC_CCS, 50))
    engine.add_charger(Charger("ac1", ChargerType.AC_TYPE2, 22, v2g_capable=True))
    engine.add_charger(Charger("ac2", ChargerType.AC_TYPE2, 22))
    
    # Set base load
    engine.base_load_kw = 30
    
    print(f"\nSite status:")
    status = engine.get_site_status()
    for key, value in status.items():
        print(f"  {key}: {value}")
    
    # Start sessions
    print(f"\n--- Start Sessions ---")
    s1 = engine.start_session("dc1", "TESLA001", current_soc=20, target_soc=80)
    s2 = engine.start_session("ac1", "BMW002", current_soc=50, target_soc=90)
    print(f"  Started: {s1.session_id}")
    print(f"  Started: {s2.session_id}")
    
    # Balance load
    print(f"\n--- Load Balancing ---")
    result = engine.balance_load()
    print(f"  Success: {result.success}")
    print(f"  Allocations: {result.allocations}")
    print(f"  Total power: {result.total_power_kw} kW")
    print(f"  Headroom: {result.headroom_kw} kW")
    
    # Set spot prices
    print(f"\n--- Smart Scheduling ---")
    now = datetime.now()
    prices = [
        (now + timedelta(hours=i), 0.10 + 0.05 * math.sin(i * 0.5))
        for i in range(24)
    ]
    engine.set_spot_prices(prices)
    
    # Update session with target time
    engine.sessions[s1.session_id].target_time = now + timedelta(hours=8)
    
    cost = engine.estimate_cost(s1.session_id)
    print(f"  Total energy: {cost.get('total_energy_kwh', 0):.1f} kWh")
    print(f"  Smart cost: ${cost.get('smart_cost', 0):.2f}")
    print(f"  Immediate cost: ${cost.get('immediate_cost', 0):.2f}")
    print(f"  Savings: ${cost.get('savings', 0):.2f}")
    
    # V2G test
    print(f"\n--- V2G Test ---")
    engine.enable_v2g(s1.session_id, min_soc=30)
    engine.sessions[s1.session_id].current_soc = 70  # Simulate charging
    
    v2g_result = engine.request_v2g_discharge(20)
    print(f"  V2G allocations: {v2g_result}")
    
    print("\n✅ EV Charging Engine test complete!")
