"""
MicrogridEngine — Intelligent Microgrid Controller

Generated by EVE Self-Coding Platform
Demonstrates: Load balancing, islanding, energy optimization

Features:
- Multi-source energy management (solar, battery, grid)
- Automatic islanding detection and response
- Load priority management
- Spot price optimization
- Real-time power flow calculation
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum
from datetime import datetime
import math


class GridMode(Enum):
    """Microgrid operating modes."""
    CONNECTED = "connected"      # Normal grid-connected operation
    ISLANDED = "islanded"        # Disconnected from main grid
    EXPORT = "export"            # Exporting excess to grid
    IMPORT = "import"            # Importing from grid
    EMERGENCY = "emergency"      # Emergency/backup mode


class LoadPriority(Enum):
    """Load priority levels for shedding."""
    CRITICAL = 1      # Never shed (life safety, critical systems)
    HIGH = 2          # Shed only in emergency
    MEDIUM = 3        # Shed when needed
    LOW = 4           # Shed first (comfort loads)
    DEFERRABLE = 5    # Can be scheduled for later


@dataclass
class EnergySource:
    """Represents an energy source in the microgrid."""
    name: str
    source_type: str              # "solar", "battery", "grid", "wind", "generator"
    capacity_kw: float            # Maximum power capacity
    current_output_kw: float = 0.0
    available: bool = True
    cost_per_kwh: float = 0.0     # Operating cost
    priority: int = 1             # Dispatch priority (1 = first)
    
    @property
    def utilization(self) -> float:
        """Current utilization percentage."""
        if self.capacity_kw <= 0:
            return 0.0
        return min(self.current_output_kw / self.capacity_kw, 1.0)


@dataclass
class Load:
    """Represents a load in the microgrid."""
    name: str
    rated_power_kw: float
    current_power_kw: float = 0.0
    priority: LoadPriority = LoadPriority.MEDIUM
    is_active: bool = True
    is_controllable: bool = True
    min_power_kw: float = 0.0     # Minimum operating power


@dataclass
class MicrogridState:
    """Current state of the microgrid."""
    timestamp: datetime
    mode: GridMode
    total_generation_kw: float
    total_load_kw: float
    battery_soc: float            # State of charge (0-100%)
    grid_power_kw: float          # Positive = import, negative = export
    frequency_hz: float = 50.0
    voltage_pu: float = 1.0       # Per-unit voltage
    spot_price: float = 0.0       # Current electricity price


@dataclass
class DispatchResult:
    """Result of energy dispatch optimization."""
    success: bool
    sources: Dict[str, float]     # Source name → dispatched power
    shed_loads: List[str]         # Loads that were shed
    grid_exchange_kw: float       # Grid import/export
    total_cost: float
    messages: List[str] = field(default_factory=list)


class MicrogridEngine:
    """
    Intelligent Microgrid Controller.
    
    Manages energy flow between multiple sources and loads,
    optimizes for cost and reliability, handles islanding.
    
    Usage:
        engine = MicrogridEngine()
        
        # Add sources
        engine.add_source(EnergySource("solar", "solar", 10.0))
        engine.add_source(EnergySource("battery", "battery", 5.0))
        
        # Add loads
        engine.add_load(Load("hvac", 3.0, priority=LoadPriority.MEDIUM))
        engine.add_load(Load("lights", 1.0, priority=LoadPriority.HIGH))
        
        # Run dispatch
        result = engine.dispatch()
    """
    
    VERSION = "1.0.0"
    
    # Thresholds
    MIN_BATTERY_SOC = 20.0        # Minimum battery SoC (%)
    CRITICAL_BATTERY_SOC = 10.0   # Emergency threshold
    FREQUENCY_DEADBAND = 0.5      # Hz deviation before action
    VOLTAGE_DEADBAND = 0.05       # PU deviation before action
    
    def __init__(self):
        """Initialize MicrogridEngine."""
        self.sources: Dict[str, EnergySource] = {}
        self.loads: Dict[str, Load] = {}
        self.mode = GridMode.CONNECTED
        self.battery_soc = 50.0
        self.spot_price = 0.10    # Default $/kWh
        self._history: List[MicrogridState] = []
        
    # ================================================================
    # SOURCE & LOAD MANAGEMENT
    # ================================================================
    
    def add_source(self, source: EnergySource) -> None:
        """Add an energy source to the microgrid."""
        self.sources[source.name] = source
        
    def remove_source(self, name: str) -> bool:
        """Remove an energy source."""
        if name in self.sources:
            del self.sources[name]
            return True
        return False
    
    def add_load(self, load: Load) -> None:
        """Add a load to the microgrid."""
        self.loads[load.name] = load
        
    def remove_load(self, name: str) -> bool:
        """Remove a load."""
        if name in self.loads:
            del self.loads[name]
            return True
        return False
    
    def update_source_output(self, name: str, power_kw: float) -> None:
        """Update current output of a source."""
        if name in self.sources:
            self.sources[name].current_output_kw = max(0, power_kw)
    
    def update_load_power(self, name: str, power_kw: float) -> None:
        """Update current power consumption of a load."""
        if name in self.loads:
            self.loads[name].current_power_kw = max(0, power_kw)
    
    # ================================================================
    # CORE DISPATCH ALGORITHM
    # ================================================================
    
    def dispatch(self, target_grid_exchange: float = None) -> DispatchResult:
        """
        Run optimal energy dispatch.
        
        Algorithm:
        1. Calculate total load
        2. Dispatch sources by priority (cheapest first)
        3. Use battery for balancing
        4. Import/export grid as needed
        5. Shed loads if necessary
        
        Args:
            target_grid_exchange: Target grid power (None = optimize)
            
        Returns:
            DispatchResult with dispatch decisions
        """
        messages = []
        
        # Calculate total load
        total_load = sum(
            load.current_power_kw 
            for load in self.loads.values() 
            if load.is_active
        )
        
        # Get available sources sorted by cost
        available_sources = [
            s for s in self.sources.values() 
            if s.available and s.source_type != "grid"
        ]
        available_sources.sort(key=lambda s: (s.priority, s.cost_per_kwh))
        
        # Dispatch sources
        dispatched: Dict[str, float] = {}
        remaining_load = total_load
        total_cost = 0.0
        
        for source in available_sources:
            if remaining_load <= 0:
                dispatched[source.name] = 0.0
                continue
                
            # Special handling for battery
            if source.source_type == "battery":
                dispatch_power = self._dispatch_battery(remaining_load)
            else:
                dispatch_power = min(source.capacity_kw, remaining_load)
            
            dispatched[source.name] = dispatch_power
            remaining_load -= dispatch_power
            total_cost += dispatch_power * source.cost_per_kwh
            
        # Grid exchange
        grid_exchange = 0.0
        if self.mode != GridMode.ISLANDED:
            if remaining_load > 0:
                # Need to import
                grid_exchange = remaining_load
                total_cost += grid_exchange * self.spot_price
                messages.append(f"Importing {grid_exchange:.1f} kW from grid")
            elif remaining_load < -1.0:  # Excess generation
                # Can export
                grid_exchange = remaining_load  # Negative = export
                messages.append(f"Exporting {-grid_exchange:.1f} kW to grid")
                
        # Load shedding if still short
        shed_loads = []
        if remaining_load > 0 and self.mode == GridMode.ISLANDED:
            shed_loads = self._shed_loads(remaining_load)
            if shed_loads:
                messages.append(f"Shed loads: {', '.join(shed_loads)}")
        
        return DispatchResult(
            success=remaining_load <= 0 or len(shed_loads) > 0,
            sources=dispatched,
            shed_loads=shed_loads,
            grid_exchange_kw=grid_exchange,
            total_cost=total_cost,
            messages=messages
        )
    
    def _dispatch_battery(self, needed_kw: float) -> float:
        """
        Dispatch battery considering SoC limits.
        
        Args:
            needed_kw: Power needed from battery
            
        Returns:
            Actual dispatch power
        """
        battery = self.sources.get("battery")
        if not battery:
            return 0.0
            
        # Don't discharge below minimum SoC
        if self.battery_soc <= self.MIN_BATTERY_SOC:
            return 0.0
            
        # Reduce output as SoC decreases
        soc_factor = (self.battery_soc - self.MIN_BATTERY_SOC) / (100 - self.MIN_BATTERY_SOC)
        max_discharge = battery.capacity_kw * soc_factor
        
        return min(needed_kw, max_discharge)
    
    def _shed_loads(self, shortage_kw: float) -> List[str]:
        """
        Shed loads to match available generation.
        
        Args:
            shortage_kw: Power shortage to eliminate
            
        Returns:
            List of shed load names
        """
        shed = []
        remaining_shortage = shortage_kw
        
        # Sort by priority (shed LOW first)
        sheddable = [
            load for load in self.loads.values()
            if load.is_controllable and load.is_active and load.priority != LoadPriority.CRITICAL
        ]
        sheddable.sort(key=lambda l: -l.priority.value)  # HIGH value = low priority
        
        for load in sheddable:
            if remaining_shortage <= 0:
                break
                
            shed.append(load.name)
            remaining_shortage -= load.current_power_kw
            load.is_active = False
            
        return shed
    
    # ================================================================
    # ISLANDING DETECTION & RESPONSE
    # ================================================================
    
    def check_islanding(self, frequency_hz: float, voltage_pu: float) -> bool:
        """
        Detect islanding condition.
        
        Args:
            frequency_hz: Measured frequency
            voltage_pu: Measured voltage (per-unit)
            
        Returns:
            True if islanding detected
        """
        freq_deviation = abs(frequency_hz - 50.0)
        volt_deviation = abs(voltage_pu - 1.0)
        
        # Simple islanding detection
        if freq_deviation > self.FREQUENCY_DEADBAND:
            return True
        if volt_deviation > self.VOLTAGE_DEADBAND:
            return True
            
        return False
    
    def enter_island_mode(self) -> None:
        """Transition to islanded operation."""
        self.mode = GridMode.ISLANDED
        
        # Disable grid source
        if "grid" in self.sources:
            self.sources["grid"].available = False
            
    def reconnect_to_grid(self) -> bool:
        """
        Attempt to reconnect to main grid.
        
        Returns:
            True if reconnection successful
        """
        # In real system: check synchronization conditions
        self.mode = GridMode.CONNECTED
        
        if "grid" in self.sources:
            self.sources["grid"].available = True
            
        return True
    
    # ================================================================
    # OPTIMIZATION
    # ================================================================
    
    def optimize_for_spot_price(self, forecast_prices: List[Tuple[datetime, float]]) -> Dict:
        """
        Optimize battery scheduling based on price forecast.
        
        Args:
            forecast_prices: List of (timestamp, price) tuples
            
        Returns:
            Schedule dict with recommended actions
        """
        schedule = {}
        avg_price = sum(p for _, p in forecast_prices) / len(forecast_prices)
        
        for timestamp, price in forecast_prices:
            if price < avg_price * 0.8:
                # Low price: charge battery
                schedule[timestamp] = {
                    "action": "charge",
                    "reason": f"Price {price:.2f} below average"
                }
            elif price > avg_price * 1.2:
                # High price: discharge battery
                schedule[timestamp] = {
                    "action": "discharge",
                    "reason": f"Price {price:.2f} above average"
                }
            else:
                schedule[timestamp] = {"action": "hold", "reason": "Normal price"}
                
        return schedule
    
    def calculate_self_sufficiency(self, hours: int = 24) -> float:
        """
        Calculate self-sufficiency ratio.
        
        Args:
            hours: Period to analyze
            
        Returns:
            Self-sufficiency percentage (0-100)
        """
        if not self._history:
            return 0.0
            
        total_load = sum(s.total_load_kw for s in self._history[-hours:])
        total_generation = sum(s.total_generation_kw for s in self._history[-hours:])
        
        if total_load <= 0:
            return 100.0
            
        return min(total_generation / total_load * 100, 100.0)
    
    # ================================================================
    # STATE & REPORTING
    # ================================================================
    
    def get_state(self) -> MicrogridState:
        """Get current microgrid state."""
        total_gen = sum(s.current_output_kw for s in self.sources.values())
        total_load = sum(l.current_power_kw for l in self.loads.values() if l.is_active)
        grid_power = total_load - total_gen
        
        state = MicrogridState(
            timestamp=datetime.now(),
            mode=self.mode,
            total_generation_kw=total_gen,
            total_load_kw=total_load,
            battery_soc=self.battery_soc,
            grid_power_kw=grid_power,
            spot_price=self.spot_price
        )
        
        self._history.append(state)
        return state
    
    def get_summary(self) -> Dict:
        """Get summary of microgrid status."""
        state = self.get_state()
        
        return {
            "mode": self.mode.value,
            "generation_kw": state.total_generation_kw,
            "load_kw": state.total_load_kw,
            "balance_kw": state.total_generation_kw - state.total_load_kw,
            "battery_soc": self.battery_soc,
            "grid_exchange_kw": state.grid_power_kw,
            "sources": {name: s.current_output_kw for name, s in self.sources.items()},
            "active_loads": [name for name, l in self.loads.items() if l.is_active],
            "self_sufficiency": self.calculate_self_sufficiency(1)
        }


# ========================================================================
# SINGLETON
# ========================================================================

_instance = None

def get_microgrid_engine() -> MicrogridEngine:
    """Get or create singleton instance."""
    global _instance
    if _instance is None:
        _instance = MicrogridEngine()
    return _instance


# ========================================================================
# CLI TEST
# ========================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("⚡ MICROGRID ENGINE — TEST")
    print("=" * 60)
    
    engine = MicrogridEngine()
    
    # Add sources
    engine.add_source(EnergySource("solar", "solar", 10.0, cost_per_kwh=0.0, priority=1))
    engine.add_source(EnergySource("battery", "battery", 5.0, cost_per_kwh=0.02, priority=2))
    engine.add_source(EnergySource("grid", "grid", 100.0, cost_per_kwh=0.15, priority=3))
    
    # Add loads
    engine.add_load(Load("critical_systems", 2.0, 2.0, LoadPriority.CRITICAL))
    engine.add_load(Load("hvac", 5.0, 4.0, LoadPriority.MEDIUM))
    engine.add_load(Load("lighting", 1.5, 1.0, LoadPriority.HIGH))
    engine.add_load(Load("ev_charger", 7.0, 0.0, LoadPriority.LOW))
    
    # Simulate solar output
    engine.update_source_output("solar", 6.0)
    engine.battery_soc = 60.0
    
    # Run dispatch
    print("\n--- Dispatch Test ---")
    result = engine.dispatch()
    
    print(f"Success: {result.success}")
    print(f"Sources: {result.sources}")
    print(f"Grid exchange: {result.grid_exchange_kw:.1f} kW")
    print(f"Total cost: ${result.total_cost:.3f}/h")
    print(f"Messages: {result.messages}")
    
    # Get summary
    print("\n--- Status Summary ---")
    summary = engine.get_summary()
    for key, value in summary.items():
        print(f"  {key}: {value}")
    
    # Test islanding
    print("\n--- Islanding Test ---")
    engine.enter_island_mode()
    print(f"Mode: {engine.mode.value}")
    
    result = engine.dispatch()
    print(f"Islanded dispatch: {result.success}")
    print(f"Shed loads: {result.shed_loads}")
    
    print("\n✅ Microgrid Engine test complete!")
