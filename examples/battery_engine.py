"""
BatteryEngine â€” Intelligent Battery Management System

Generated by EVE Self-Coding Platform
Demonstrates: SoC/SoH calculation, cycle tracking, thermal management

Features:
- State of Charge (SoC) estimation
- State of Health (SoH) tracking
- Cycle counting and degradation
- Thermal management
- Charge/discharge optimization
"""

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Tuple
from enum import Enum
from datetime import datetime, timedelta
import math


class BatteryState(Enum):
    """Battery operating states."""
    IDLE = "idle"
    CHARGING = "charging"
    DISCHARGING = "discharging"
    BALANCING = "balancing"
    FAULT = "fault"
    OFFLINE = "offline"


class BatteryChemistry(Enum):
    """Battery chemistry types with characteristics."""
    LIFEPO4 = "lifepo4"      # Lithium Iron Phosphate
    NMC = "nmc"              # Nickel Manganese Cobalt
    LTO = "lto"              # Lithium Titanate
    LEAD_ACID = "lead_acid"  # Lead Acid


@dataclass
class BatteryConfig:
    """Battery configuration parameters."""
    chemistry: BatteryChemistry = BatteryChemistry.LIFEPO4
    nominal_capacity_kwh: float = 10.0
    nominal_voltage: float = 48.0
    max_charge_rate_c: float = 1.0      # C-rate
    max_discharge_rate_c: float = 1.0
    min_soc: float = 10.0               # %
    max_soc: float = 90.0               # %
    min_temp_c: float = 0.0
    max_temp_c: float = 45.0
    cycle_life: int = 6000              # Expected cycles


@dataclass
class BatteryStatus:
    """Current battery status."""
    timestamp: datetime
    state: BatteryState
    soc: float                          # State of Charge (%)
    soh: float                          # State of Health (%)
    voltage: float                      # Current voltage (V)
    current: float                      # Current (A), positive = charging
    power_kw: float                     # Power (kW)
    temperature: float                  # Temperature (Â°C)
    cycles: float                       # Total equivalent cycles
    available_energy_kwh: float         # Available energy


@dataclass
class ChargeResult:
    """Result of charge/discharge operation."""
    success: bool
    energy_kwh: float = 0.0
    duration_hours: float = 0.0
    avg_power_kw: float = 0.0
    message: str = ""


class BatteryEngine:
    """
    Intelligent Battery Management System.
    
    Features:
    - Accurate SoC estimation using Coulomb counting + OCV
    - SoH tracking based on capacity fade
    - Cycle counting with depth-of-discharge weighting
    - Thermal protection and management
    - Optimal charge/discharge scheduling
    
    Usage:
        engine = BatteryEngine()
        engine.configure(BatteryConfig(nominal_capacity_kwh=13.5))
        
        # Charge
        result = engine.charge(power_kw=5.0, duration_hours=2.0)
        
        # Get status
        status = engine.get_status()
        print(f"SoC: {status.soc}%, SoH: {status.soh}%")
    """
    
    VERSION = "1.0.0"
    
    # OCV-SoC lookup table for LiFePO4 (voltage per cell)
    OCV_TABLE_LIFEPO4 = [
        (0, 2.80), (10, 3.10), (20, 3.20), (30, 3.25),
        (40, 3.27), (50, 3.28), (60, 3.30), (70, 3.32),
        (80, 3.35), (90, 3.40), (100, 3.65)
    ]
    
    def __init__(self):
        """Initialize BatteryEngine."""
        self.config = BatteryConfig()
        self.state = BatteryState.IDLE
        
        # State variables
        self._soc = 50.0                # Current SoC (%)
        self._soh = 100.0               # State of Health (%)
        self._voltage = 48.0            # Current voltage
        self._current = 0.0             # Current (A)
        self._temperature = 25.0        # Temperature (Â°C)
        self._total_cycles = 0.0        # Equivalent full cycles
        self._total_energy_throughput = 0.0  # Total kWh cycled
        
        # Tracking
        self._last_soc = 50.0
        self._cycle_start_soc = 50.0
        self._history: List[BatteryStatus] = []
        
    def configure(self, config: BatteryConfig) -> None:
        """Apply battery configuration."""
        self.config = config
        self._voltage = config.nominal_voltage
        
    # ================================================================
    # STATE OF CHARGE
    # ================================================================
    
    def get_soc(self) -> float:
        """Get current State of Charge."""
        return round(self._soc, 1)
    
    def set_soc(self, soc: float) -> None:
        """Manually set SoC (for calibration)."""
        self._soc = max(0, min(100, soc))
        
    def estimate_soc_from_voltage(self, voltage: float) -> float:
        """
        Estimate SoC from Open Circuit Voltage.
        Should only be used when battery is at rest.
        
        Args:
            voltage: Measured OCV
            
        Returns:
            Estimated SoC (%)
        """
        # Calculate per-cell voltage (assuming 16S for 48V system)
        cells_in_series = round(self.config.nominal_voltage / 3.2)
        cell_voltage = voltage / cells_in_series
        
        # Linear interpolation in OCV table
        table = self.OCV_TABLE_LIFEPO4
        
        for i in range(len(table) - 1):
            soc1, v1 = table[i]
            soc2, v2 = table[i + 1]
            
            if v1 <= cell_voltage <= v2:
                # Linear interpolation
                ratio = (cell_voltage - v1) / (v2 - v1)
                return soc1 + ratio * (soc2 - soc1)
        
        # Out of range
        if cell_voltage < table[0][1]:
            return 0.0
        return 100.0
    
    def update_soc_coulomb(self, current_a: float, duration_hours: float) -> float:
        """
        Update SoC using Coulomb counting.
        
        Args:
            current_a: Average current (positive = charging)
            duration_hours: Time period
            
        Returns:
            New SoC
        """
        # Calculate capacity in Ah
        capacity_ah = (self.config.nominal_capacity_kwh * 1000) / self.config.nominal_voltage
        
        # Account for SoH
        effective_capacity = capacity_ah * (self._soh / 100)
        
        # Calculate charge transfer
        charge_ah = current_a * duration_hours
        
        # Efficiency factors
        if current_a > 0:  # Charging
            efficiency = 0.95
        else:  # Discharging
            efficiency = 0.98
            
        soc_change = (charge_ah * efficiency / effective_capacity) * 100
        
        self._last_soc = self._soc
        self._soc = max(0, min(100, self._soc + soc_change))
        
        # Track energy throughput
        self._total_energy_throughput += abs(charge_ah * self._voltage / 1000)
        
        return self._soc
    
    # ================================================================
    # STATE OF HEALTH
    # ================================================================
    
    def get_soh(self) -> float:
        """Get current State of Health."""
        return round(self._soh, 1)
    
    def update_soh(self) -> float:
        """
        Update SoH based on cycle count and calendar aging.
        
        Returns:
            Updated SoH (%)
        """
        # Cycle-based degradation
        cycle_degradation = (self._total_cycles / self.config.cycle_life) * 20  # 20% capacity loss at EOL
        
        # Temperature-based acceleration (simplified)
        temp_factor = 1.0
        if self._temperature > 35:
            temp_factor = 1.0 + (self._temperature - 35) * 0.02
        
        # Calculate new SoH
        self._soh = max(0, 100 - cycle_degradation * temp_factor)
        
        return self._soh
    
    def count_cycle(self) -> None:
        """
        Count partial cycles using rainflow-like method.
        Tracks depth of discharge for weighted cycle counting.
        """
        dod = abs(self._soc - self._last_soc)
        
        # Weighted cycle count (deeper cycles count more)
        # Based on Palmgren-Miner rule
        if dod > 5:  # Ignore micro-cycles
            cycle_weight = (dod / 100) ** 1.5  # Non-linear weighting
            self._total_cycles += cycle_weight
            self.update_soh()
    
    # ================================================================
    # CHARGE / DISCHARGE
    # ================================================================
    
    def charge(self, power_kw: float, duration_hours: float = None, target_soc: float = None) -> ChargeResult:
        """
        Charge the battery.
        
        Args:
            power_kw: Charge power
            duration_hours: Charge duration (or until target)
            target_soc: Target SoC (default: max_soc)
            
        Returns:
            ChargeResult
        """
        # Validate
        if self._temperature < self.config.min_temp_c:
            return ChargeResult(False, message=f"Temperature too low: {self._temperature}Â°C")
        if self._temperature > self.config.max_temp_c:
            return ChargeResult(False, message=f"Temperature too high: {self._temperature}Â°C")
        
        target_soc = target_soc or self.config.max_soc
        
        # Limit power to max charge rate
        max_power = self.config.nominal_capacity_kwh * self.config.max_charge_rate_c
        actual_power = min(power_kw, max_power)
        
        # Calculate current
        current = (actual_power * 1000) / self._voltage
        
        # Calculate time to target
        capacity_kwh = self.config.nominal_capacity_kwh * (self._soh / 100)
        energy_needed = capacity_kwh * (target_soc - self._soc) / 100
        time_to_target = energy_needed / actual_power if actual_power > 0 else float('inf')
        
        # Use shorter of duration or time to target
        actual_duration = min(duration_hours or float('inf'), time_to_target)
        
        if actual_duration <= 0:
            return ChargeResult(False, message="Already at target SoC")
        
        # Update state
        self.state = BatteryState.CHARGING
        self._current = current
        
        # Update SoC
        self.update_soc_coulomb(current, actual_duration)
        self.count_cycle()
        
        # Calculate actual energy
        energy = actual_power * actual_duration
        
        self.state = BatteryState.IDLE
        self._current = 0
        
        return ChargeResult(
            success=True,
            energy_kwh=energy,
            duration_hours=actual_duration,
            avg_power_kw=actual_power,
            message=f"Charged to {self._soc:.1f}%"
        )
    
    def discharge(self, power_kw: float, duration_hours: float = None, target_soc: float = None) -> ChargeResult:
        """
        Discharge the battery.
        
        Args:
            power_kw: Discharge power
            duration_hours: Discharge duration
            target_soc: Target SoC (default: min_soc)
            
        Returns:
            ChargeResult
        """
        target_soc = target_soc or self.config.min_soc
        
        # Limit power to max discharge rate
        max_power = self.config.nominal_capacity_kwh * self.config.max_discharge_rate_c
        actual_power = min(power_kw, max_power)
        
        # Calculate time to target
        capacity_kwh = self.config.nominal_capacity_kwh * (self._soh / 100)
        energy_available = capacity_kwh * (self._soc - target_soc) / 100
        time_to_target = energy_available / actual_power if actual_power > 0 else float('inf')
        
        actual_duration = min(duration_hours or float('inf'), time_to_target)
        
        if actual_duration <= 0:
            return ChargeResult(False, message="At minimum SoC")
        
        # Update state
        self.state = BatteryState.DISCHARGING
        current = -(actual_power * 1000) / self._voltage  # Negative for discharge
        self._current = current
        
        self.update_soc_coulomb(current, actual_duration)
        self.count_cycle()
        
        energy = actual_power * actual_duration
        
        self.state = BatteryState.IDLE
        self._current = 0
        
        return ChargeResult(
            success=True,
            energy_kwh=energy,
            duration_hours=actual_duration,
            avg_power_kw=actual_power,
            message=f"Discharged to {self._soc:.1f}%"
        )
    
    # ================================================================
    # THERMAL MANAGEMENT
    # ================================================================
    
    def update_temperature(self, ambient_temp: float, power_kw: float) -> float:
        """
        Update battery temperature based on load and ambient.
        
        Args:
            ambient_temp: Ambient temperature (Â°C)
            power_kw: Current power (absolute)
            
        Returns:
            New temperature
        """
        # Simplified thermal model
        internal_resistance = 0.05  # Ohms (example)
        current = (power_kw * 1000) / self._voltage
        heat_generation = current ** 2 * internal_resistance  # Watts
        
        # Temperature rise (simplified)
        thermal_mass = 50  # Wh/Â°C (example)
        temp_rise = heat_generation / (thermal_mass * 3.6)  # Â°C/hour approx
        
        # Approach ambient with time constant
        tau = 2.0  # hours
        self._temperature = ambient_temp + (self._temperature - ambient_temp) * 0.9 + temp_rise
        
        return self._temperature
    
    def is_temperature_safe(self) -> bool:
        """Check if temperature is within safe limits."""
        return self.config.min_temp_c <= self._temperature <= self.config.max_temp_c
    
    # ================================================================
    # STATUS & REPORTING
    # ================================================================
    
    def get_status(self) -> BatteryStatus:
        """Get comprehensive battery status."""
        available_energy = (
            self.config.nominal_capacity_kwh * 
            (self._soh / 100) * 
            (self._soc - self.config.min_soc) / 100
        )
        
        status = BatteryStatus(
            timestamp=datetime.now(),
            state=self.state,
            soc=self._soc,
            soh=self._soh,
            voltage=self._voltage,
            current=self._current,
            power_kw=abs(self._current * self._voltage / 1000),
            temperature=self._temperature,
            cycles=self._total_cycles,
            available_energy_kwh=max(0, available_energy)
        )
        
        self._history.append(status)
        return status
    
    def get_remaining_life(self) -> Dict:
        """Estimate remaining battery life."""
        remaining_cycles = max(0, self.config.cycle_life - self._total_cycles)
        
        # Estimate based on recent usage
        if len(self._history) > 100:
            recent_throughput = self._total_energy_throughput / max(1, len(self._history))
            estimated_cycles_per_day = recent_throughput / (self.config.nominal_capacity_kwh * 2)
            remaining_days = remaining_cycles / max(0.1, estimated_cycles_per_day)
        else:
            remaining_days = None
            
        return {
            "soh_percent": self._soh,
            "total_cycles": self._total_cycles,
            "remaining_cycles": remaining_cycles,
            "estimated_remaining_days": remaining_days,
            "total_energy_throughput_kwh": self._total_energy_throughput
        }


# ========================================================================
# SINGLETON
# ========================================================================

_instance = None

def get_battery_engine() -> BatteryEngine:
    """Get or create singleton instance."""
    global _instance
    if _instance is None:
        _instance = BatteryEngine()
    return _instance


# ========================================================================
# CLI TEST
# ========================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("ðŸ”‹ BATTERY ENGINE â€” TEST")
    print("=" * 60)
    
    engine = BatteryEngine()
    engine.configure(BatteryConfig(
        chemistry=BatteryChemistry.LIFEPO4,
        nominal_capacity_kwh=13.5,
        nominal_voltage=48.0
    ))
    
    # Set initial state
    engine.set_soc(30.0)
    engine._temperature = 25.0
    
    print(f"\nInitial state:")
    status = engine.get_status()
    print(f"  SoC: {status.soc}%")
    print(f"  SoH: {status.soh}%")
    print(f"  Available energy: {status.available_energy_kwh:.2f} kWh")
    
    # Test charging
    print(f"\n--- Charge Test ---")
    result = engine.charge(power_kw=5.0, target_soc=80.0)
    print(f"  {result.message}")
    print(f"  Energy: {result.energy_kwh:.2f} kWh")
    print(f"  Duration: {result.duration_hours:.2f} h")
    
    # Test discharging
    print(f"\n--- Discharge Test ---")
    result = engine.discharge(power_kw=3.0, duration_hours=1.5)
    print(f"  {result.message}")
    print(f"  Energy: {result.energy_kwh:.2f} kWh")
    
    # Final status
    print(f"\n--- Final Status ---")
    status = engine.get_status()
    print(f"  SoC: {status.soc}%")
    print(f"  Cycles: {status.cycles:.2f}")
    print(f"  Temperature: {status.temperature:.1f}Â°C")
    
    # Remaining life
    print(f"\n--- Remaining Life ---")
    life = engine.get_remaining_life()
    print(f"  SoH: {life['soh_percent']:.1f}%")
    print(f"  Remaining cycles: {life['remaining_cycles']:.0f}")
    
    print("\nâœ… Battery Engine test complete!")
